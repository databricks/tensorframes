// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/tensor.proto

package org.tensorflow.framework;

public interface TensorProtoOrBuilder extends
    // @@protoc_insertion_point(interface_extends:tensorflow.TensorProto)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>optional .tensorflow.DataType dtype = 1;</code>
   */
  int getDtypeValue();
  /**
   * <code>optional .tensorflow.DataType dtype = 1;</code>
   */
  org.tensorflow.framework.DataType getDtype();

  /**
   * <code>optional .tensorflow.TensorShapeProto tensor_shape = 2;</code>
   *
   * <pre>
   * Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
   * </pre>
   */
  boolean hasTensorShape();
  /**
   * <code>optional .tensorflow.TensorShapeProto tensor_shape = 2;</code>
   *
   * <pre>
   * Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
   * </pre>
   */
  org.tensorflow.framework.TensorShapeProto getTensorShape();
  /**
   * <code>optional .tensorflow.TensorShapeProto tensor_shape = 2;</code>
   *
   * <pre>
   * Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
   * </pre>
   */
  org.tensorflow.framework.TensorShapeProtoOrBuilder getTensorShapeOrBuilder();

  /**
   * <code>optional int32 version_number = 3;</code>
   *
   * <pre>
   * Version number.
   * In version 0, if the "repeated xxx" representations contain only one
   * element, that element is repeated to fill the shape.  This makes it easy
   * to represent a constant Tensor with a single value.
   * </pre>
   */
  int getVersionNumber();

  /**
   * <code>optional bytes tensor_content = 4;</code>
   *
   * <pre>
   * Serialized content from Tensor::AsProtoTensorContent(). This representation
   * can be used for all tensor types.
   * </pre>
   */
  com.google.protobuf.ByteString getTensorContent();

  /**
   * <code>repeated float float_val = 5 [packed = true];</code>
   *
   * <pre>
   * DT_FLOAT.
   * </pre>
   */
  java.util.List<java.lang.Float> getFloatValList();
  /**
   * <code>repeated float float_val = 5 [packed = true];</code>
   *
   * <pre>
   * DT_FLOAT.
   * </pre>
   */
  int getFloatValCount();
  /**
   * <code>repeated float float_val = 5 [packed = true];</code>
   *
   * <pre>
   * DT_FLOAT.
   * </pre>
   */
  float getFloatVal(int index);

  /**
   * <code>repeated double double_val = 6 [packed = true];</code>
   *
   * <pre>
   * DT_DOUBLE.
   * </pre>
   */
  java.util.List<java.lang.Double> getDoubleValList();
  /**
   * <code>repeated double double_val = 6 [packed = true];</code>
   *
   * <pre>
   * DT_DOUBLE.
   * </pre>
   */
  int getDoubleValCount();
  /**
   * <code>repeated double double_val = 6 [packed = true];</code>
   *
   * <pre>
   * DT_DOUBLE.
   * </pre>
   */
  double getDoubleVal(int index);

  /**
   * <code>repeated int32 int_val = 7 [packed = true];</code>
   *
   * <pre>
   * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
   * </pre>
   */
  java.util.List<java.lang.Integer> getIntValList();
  /**
   * <code>repeated int32 int_val = 7 [packed = true];</code>
   *
   * <pre>
   * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
   * </pre>
   */
  int getIntValCount();
  /**
   * <code>repeated int32 int_val = 7 [packed = true];</code>
   *
   * <pre>
   * DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
   * </pre>
   */
  int getIntVal(int index);

  /**
   * <code>repeated bytes string_val = 8;</code>
   *
   * <pre>
   * DT_STRING
   * </pre>
   */
  java.util.List<com.google.protobuf.ByteString> getStringValList();
  /**
   * <code>repeated bytes string_val = 8;</code>
   *
   * <pre>
   * DT_STRING
   * </pre>
   */
  int getStringValCount();
  /**
   * <code>repeated bytes string_val = 8;</code>
   *
   * <pre>
   * DT_STRING
   * </pre>
   */
  com.google.protobuf.ByteString getStringVal(int index);

  /**
   * <code>repeated float scomplex_val = 9 [packed = true];</code>
   *
   * <pre>
   * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
   * and imaginary parts of i-th single precision complex.
   * </pre>
   */
  java.util.List<java.lang.Float> getScomplexValList();
  /**
   * <code>repeated float scomplex_val = 9 [packed = true];</code>
   *
   * <pre>
   * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
   * and imaginary parts of i-th single precision complex.
   * </pre>
   */
  int getScomplexValCount();
  /**
   * <code>repeated float scomplex_val = 9 [packed = true];</code>
   *
   * <pre>
   * DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
   * and imaginary parts of i-th single precision complex.
   * </pre>
   */
  float getScomplexVal(int index);

  /**
   * <code>repeated int64 int64_val = 10 [packed = true];</code>
   *
   * <pre>
   * DT_INT64
   * </pre>
   */
  java.util.List<java.lang.Long> getInt64ValList();
  /**
   * <code>repeated int64 int64_val = 10 [packed = true];</code>
   *
   * <pre>
   * DT_INT64
   * </pre>
   */
  int getInt64ValCount();
  /**
   * <code>repeated int64 int64_val = 10 [packed = true];</code>
   *
   * <pre>
   * DT_INT64
   * </pre>
   */
  long getInt64Val(int index);

  /**
   * <code>repeated bool bool_val = 11 [packed = true];</code>
   *
   * <pre>
   * DT_BOOL
   * </pre>
   */
  java.util.List<java.lang.Boolean> getBoolValList();
  /**
   * <code>repeated bool bool_val = 11 [packed = true];</code>
   *
   * <pre>
   * DT_BOOL
   * </pre>
   */
  int getBoolValCount();
  /**
   * <code>repeated bool bool_val = 11 [packed = true];</code>
   *
   * <pre>
   * DT_BOOL
   * </pre>
   */
  boolean getBoolVal(int index);
}
